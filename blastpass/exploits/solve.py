#!/usr/bin/env python3

import requests
import string
import os

def run_challenge(input_str, vault_id=75, base_url="http://192.168.56.10:3333"):
    """Download vault from web server and return size"""
    session = requests.Session()
    
    # Download vault with comment
    download_url = f"{base_url}/download/{vault_id}"
    response = session.get(download_url)
    if response.status_code != 200:
        return None
    
    # POST comment and get encrypted vault
    download_data = {"comment": input_str}
    response = session.post(download_url, data=download_data)
    
    if response.status_code == 200:
        encrypted_bytes = response.content
        return len(encrypted_bytes)
    
    return None


def find_flag():
    # Character set to try (base64 chars - no braces since format is FLAG_XXXXXXXX)
    charset = string.ascii_letters + string.digits + "+/=_-"

    # Start with known flag prefix
    known_flag = "FLAG_"

    print(f"Starting with known prefix: {known_flag}")
    
    # Track recent characters to detect loops
    recent_chars = []
    loop_detection_window = 4

    while True:
        best_chars = []
        best_length = float("inf")

        print(f"\nTrying to find next character after: {known_flag}")

        # Detect actual loops - only when the SAME sequence repeats multiple times
        # (not just similar patterns that naturally occur in base64)
        if len(recent_chars) >= loop_detection_window * 3:  # Need at least 3 repetitions
            pattern = ''.join(recent_chars[-loop_detection_window:])
            prev_pattern = ''.join(recent_chars[-loop_detection_window*2:-loop_detection_window])
            prev_prev_pattern = ''.join(recent_chars[-loop_detection_window*3:-loop_detection_window*2])
            
            # Only backtrack if we see the EXACT same pattern 3 times in a row
            if pattern == prev_pattern == prev_prev_pattern:
                print(f"⚠️  REAL LOOP DETECTED: '{pattern}' repeated 3+ times - BACKTRACKING")
                # Remove only the most recent repetition
                known_flag = known_flag[:-loop_detection_window]
                recent_chars = recent_chars[:-loop_detection_window]
                print(f"Backtracked to: {known_flag}")
                continue

        # Add compression context separation to prevent false LZ77 matches
        # Use random padding to reset compression context
        padding = f"NOISE_{len(known_flag)}_SEPARATOR_"
        
        # Get baseline compression with current known flag
        baseline_len = run_challenge(padding + known_flag + "X")  # Use 'X' as baseline

        # Try each character
        for char in charset:
            test_string = padding + known_flag + char
            compressed_len = run_challenge(test_string)

            if compressed_len is None:
                continue

            # Only show best candidates to reduce output noise
            if compressed_len <= best_length:
                print(
                    f"  {test_string:<40} -> {compressed_len} bytes {'*' if compressed_len < best_length else ''}"
                )

            # Look for the shortest compressed length (best compression)
            if compressed_len < best_length:
                best_length = compressed_len
                best_chars = [char]
            elif compressed_len == best_length:
                best_chars.append(char)

        if not best_chars:
            print("No characters found, stopping")
            break

        # If multiple characters have the same best compression, try disambiguation
        if len(best_chars) > 1:
            print(
                f"Multiple candidates with same compression ({best_length} bytes): {best_chars}"
            )

            # Method 1: Try common next characters to see which leads to better compression
            best_char = None
            best_lookahead_score = float("inf")

            for char in best_chars:
                # Try a few common next characters for base64 content (no } since no braces in format)
                test_chars = [
                    "a",
                    "A",
                    "0",
                    "R",
                    "T",
                    "V",
                    "J",
                    "8",
                    "=",
                    "L",
                    "U",
                    "d",
                    "B",
                ]
                total_score = 0
                valid_tests = 0

                for next_char in test_chars:
                    test_string = known_flag + char + next_char
                    compressed_len = run_challenge(test_string)
                    if compressed_len is not None:
                        total_score += compressed_len
                        valid_tests += 1

                if valid_tests > 0:
                    avg_score = total_score / valid_tests
                    print(f"  '{char}': lookahead avg = {avg_score:.2f}")
                    if avg_score < best_lookahead_score:
                        best_lookahead_score = avg_score
                        best_char = char

            # If still tied or no clear winner, try method 2: pattern matching
            if best_char is None:
                print("  Trying pattern-based disambiguation...")
                # For base64-like flags, certain patterns are more common
                if len(known_flag) >= 8:  # We have some context
                    # Prefer characters that follow base64 patterns
                    for char in best_chars:
                        if char.isalnum():  # Alphanumeric chars are common in base64
                            best_char = char
                            print(f"  Selected '{char}' based on base64 pattern")
                            break

            # Final fallback
            if best_char is None:
                best_char = best_chars[0]
                print(f"  Using fallback: '{best_char}'")
        else:
            best_char = best_chars[0]

        # Add the best character to our known flag
        known_flag += best_char
        recent_chars.append(best_char)
        
        # Keep only recent chars for loop detection
        if len(recent_chars) > loop_detection_window * 2:
            recent_chars.pop(0)
            
        print(f"\n{'='*60}")
        print(f"FOUND: '{best_char}' (compression: {best_length} bytes)")
        print(f"FLAG SO FAR: {known_flag}")
        print(f"RECENT CHARS: {''.join(recent_chars[-8:])}")  # Show last 8 chars
        print(
            f"PROGRESS: {len(known_flag)}/37 characters ({len(known_flag)-5}/32 after FLAG_)"
        )
        print(f"{'='*60}")

        # Stop conditions - FLAG_ + 32 chars = 37 total
        if len(known_flag) >= 37:
            print("Reached expected flag length (37 characters) - flag complete!")
            break

        # If compression is getting worse and we're close to expected length
        if len(known_flag) > 30 and best_length >= baseline_len:
            print("Compression getting worse near expected end - likely complete")
            break

        # Safety check to prevent infinite loops
        if len(known_flag) > 40:
            print("Flag longer than expected, stopping")
            break

    return known_flag


def main():
    print("CRIME-like Attack on Compression + Encryption")
    print("=" * 50)

    # Test basic functionality first
    # print("\nTesting basic functionality:")
    # test_len1 = run_challenge("test")
    # test_len2 = run_challenge("FLAG")
    #
    # print(f"Input 'test' -> {test_len1} bytes")
    # print(f"Input 'FLAG' -> {test_len2} bytes")
    #
    # if test_len2 < test_len1:
    #     print("✓ CRIME attack is working! 'FLAG' compresses better.")
    # else:
    #     print("✗ CRIME attack not working as expected")
    #     return
    #
    # Find the flag
    print("\nStarting flag extraction...")
    flag = find_flag()

    print(f"\n{'='*50}")
    print(f"Final flag: {flag}")
    print(f"{'='*50}")


if __name__ == "__main__":
    main()
