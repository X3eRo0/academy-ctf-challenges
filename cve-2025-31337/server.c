#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define _POSIX_C_SOURCE 200112L
#include <unistd.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <signal.h>
#include <errno.h>
#include <time.h>
#include "ftp_server.h"

static char* g_db_path = NULL;
static char* g_root_dir = NULL;

void sigchld_handler(int sig)
{
    while (waitpid(-1, NULL, WNOHANG) > 0)
        ;
}

int start_server(int port, const char* db_path, const char* root_dir)
{
    int server_fd, client_fd;
    struct sockaddr_in server_addr, client_addr;
    socklen_t client_len = sizeof(client_addr);
    int opt = 1;

    // Store global paths
    g_db_path = strdup(db_path);
    g_root_dir = strdup(root_dir);

    // Initialize database
    if (init_database(db_path) != 0) {
        fprintf(stderr, "Failed to initialize database\n");
        return -1;
    }

    // Create socket
    server_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (server_fd < 0) {
        perror("socket failed");
        return -1;
    }

    // Set socket options
    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) < 0) {
        perror("setsockopt failed");
        close(server_fd);
        return -1;
    }

    // Configure server address
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(port);

    // Bind socket
    if (bind(server_fd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {
        perror("bind failed");
        close(server_fd);
        return -1;
    }

    // Listen for connections
    if (listen(server_fd, 10) < 0) {
        perror("listen failed");
        close(server_fd);
        return -1;
    }

    // Set up signal handler for child processes
    signal(SIGCHLD, sigchld_handler);

    printf("FTP Server listening on port %d\n", port);
    printf("Database: %s\n", db_path);
    printf("Root directory: %s\n", root_dir);

    while (1) {
        client_fd = accept(server_fd, (struct sockaddr*)&client_addr, &client_len);
        if (client_fd < 0) {
            if (errno == EINTR)
                continue; // Interrupted by signal
            perror("accept failed");
            continue;
        }

        printf("New connection from %s:%d\n",
            inet_ntoa(client_addr.sin_addr),
            ntohs(client_addr.sin_port));

        // Fork a child process to handle the client
        pid_t pid = fork();
        if (pid == 0) {
            // Child process
            close(server_fd); // Child doesn't need the listening socket

            // Create client session
            client_session_t session;
            memset(&session, 0, sizeof(session));
            session.socket_fd = client_fd;
            session.client_addr = client_addr;
            session.authenticated = 0;
            session.pid = getpid();
            strcpy(session.current_dir, "/");

            // Handle client
            int result = handle_client(&session);

            close(client_fd);
            exit(result);
        } else if (pid > 0) {
            // Parent process
            close(client_fd); // Parent doesn't need the client socket
        } else {
            perror("fork failed");
            close(client_fd);
        }
    }

    close(server_fd);
    free(g_db_path);
    free(g_root_dir);
    return 0;
}

int handle_client(client_session_t* session)
{
    packet_header_t header;
    char buffer[MAX_PACKET_SIZE];

    printf("[PID %d] Handling client connection\n", session->pid);

    while (1) {
        // Receive packet
        int result = recv_packet(session->socket_fd, &header, buffer, sizeof(buffer));
        if (result <= 0) {
            printf("[PID %d] Client disconnected\n", session->pid);
            break;
        }

        // Handle authentication first
        if (!session->authenticated) {
            if (header.type == CMD_LOGIN) {
                // Parse login data
                if (header.length < 2) {
                    send_error_response(session->socket_fd, "Invalid login format");
                    continue;
                }

                uint8_t username_len = buffer[0];
                if (username_len > MAX_USERNAME_LEN || header.length < username_len + 2) {
                    send_error_response(session->socket_fd, "Invalid username length");
                    continue;
                }

                char username[MAX_USERNAME_LEN + 1];
                memcpy(username, buffer + 1, username_len);
                username[username_len] = '\0';

                uint8_t password_len = buffer[1 + username_len];
                if (password_len > MAX_PASSWORD_LEN || header.length < username_len + password_len + 2) {
                    send_error_response(session->socket_fd, "Invalid password length");
                    continue;
                }

                char password[MAX_PASSWORD_LEN + 1];
                memcpy(password, buffer + 2 + username_len, password_len);
                password[password_len] = '\0';

                // Authenticate user
                session->user = malloc(sizeof(user_t));
                if (authenticate_user(username, password, session->user) == 0) {
                    session->authenticated = 1;

                    // Setup chroot to user's home directory
                    char full_path[MAX_PATH_LEN];
                    snprintf(full_path, sizeof(full_path), "%s/%s",
                        g_root_dir, session->user->home_directory);

                    printf("full_path: %s\n", full_path);
                    if (setup_chroot(full_path) != 0) {
                        send_error_response(session->socket_fd, "Failed to setup user environment");
                        free(session->user);
                        session->user = NULL;
                        continue;
                    }

                    send_success_response(session->socket_fd, "Login successful");
                    printf("[PID %d] User '%s' authenticated\n", session->pid, username);
                } else {
                    send_error_response(session->socket_fd, "Authentication failed");
                    free(session->user);
                    session->user = NULL;
                }
            } else if (header.type == CMD_ANONYMOUS) {
                // Anonymous login
                session->user = malloc(sizeof(user_t));
                if (authenticate_anonymous(session->user) == 0) {
                    session->authenticated = 1;

                    // Setup chroot to anonymous directory
                    char full_path[MAX_PATH_LEN];
                    snprintf(full_path, sizeof(full_path), "%s/anonymous", g_root_dir);

                    if (setup_chroot(full_path) != 0) {
                        send_error_response(session->socket_fd, "Failed to setup anonymous environment");
                        free(session->user);
                        session->user = NULL;
                        continue;
                    }

                    send_success_response(session->socket_fd, "Anonymous login successful");
                    printf("[PID %d] Anonymous user authenticated\n", session->pid);
                } else {
                    send_error_response(session->socket_fd, "Anonymous login failed");
                    free(session->user);
                    session->user = NULL;
                }
            } else if (header.type == CMD_REGISTER) {
                // User registration
                if (header.length < 2) {
                    send_error_response(session->socket_fd, "Invalid registration format");
                    continue;
                }

                uint8_t username_len = buffer[0];
                if (username_len > MAX_USERNAME_LEN || header.length < username_len + 2) {
                    send_error_response(session->socket_fd, "Invalid username length");
                    continue;
                }

                char username[MAX_USERNAME_LEN + 1];
                memcpy(username, buffer + 1, username_len);
                username[username_len] = '\0';

                uint8_t password_len = buffer[1 + username_len];
                if (password_len > MAX_PASSWORD_LEN || header.length < username_len + password_len + 2) {
                    send_error_response(session->socket_fd, "Invalid password length");
                    continue;
                }

                char password[MAX_PASSWORD_LEN + 1];
                memcpy(password, buffer + 2 + username_len, password_len);
                password[password_len] = '\0';

                // Generate unique temporary directory name
                char home_dir[MAX_PATH_LEN];
                snprintf(home_dir, sizeof(home_dir), "temp_%s_%ld", username, time(NULL));

                // Create user in database
                if (create_user(username, password, home_dir) == 0) {
                    // Create the physical directory
                    char full_home_path[MAX_PATH_LEN];
                    snprintf(full_home_path, sizeof(full_home_path), "%s/%s", g_root_dir, home_dir);

                    if (mkdir(full_home_path, 0755) == 0) {
                        // Authenticate the newly created user
                        session->user = malloc(sizeof(user_t));
                        if (authenticate_user(username, password, session->user) == 0) {
                            session->authenticated = 1;

                            // Setup chroot to user's new directory
                            if (setup_chroot(full_home_path) != 0) {
                                send_error_response(session->socket_fd, "Failed to setup user environment");
                                free(session->user);
                                session->user = NULL;
                                continue;
                            }

                            send_success_response(session->socket_fd, "Registration and login successful");
                            printf("[PID %d] User '%s' registered and authenticated with home '%s'\n",
                                session->pid, username, home_dir);
                        } else {
                            send_error_response(session->socket_fd, "Registration successful but authentication failed");
                            free(session->user);
                            session->user = NULL;
                        }
                    } else {
                        send_error_response(session->socket_fd, "Failed to create user directory");
                    }
                } else {
                    send_error_response(session->socket_fd, "Registration failed - username may already exist");
                }
            } else {
                send_error_response(session->socket_fd, "Authentication required");
            }
        } else {
            // Process authenticated commands
            result = process_command(session, &header, buffer);
            if (result < 0) {
                printf("[PID %d] Command processing failed\n", session->pid);
                break;
            }
        }
    }

    if (session->user) {
        free(session->user);
    }

    return 0;
}

int process_command(client_session_t* session, packet_header_t* header, void* data)
{
    switch (header->type) {
    case CMD_GET:
        return handle_get(session, data, header->length);
    case CMD_PUT:
        return handle_put(session, data, header->length);
    case CMD_LIST:
        return handle_list(session, data, header->length);
    case CMD_MKDIR:
        return handle_mkdir(session, data, header->length);
    case CMD_DELETE:
        return handle_delete(session, data, header->length);
    case CMD_RENAME:
        return handle_rename(session, data, header->length);
    case CMD_STAT:
        return handle_stat(session, data, header->length);
    case CMD_SEARCH:
        return handle_search(session, data, header->length);
    default:
        send_error_response(session->socket_fd, "Unknown command");
        return -1;
    }
}

int main(int argc, char* argv[])
{
    if (argc != 4) {
        fprintf(stderr, "Usage: %s <port> <database_path> <root_directory>\n", argv[0]);
        return 1;
    }

    int port = atoi(argv[1]);
    const char* db_path = argv[2];
    const char* root_dir = argv[3];

    if (port <= 0 || port > 65535) {
        fprintf(stderr, "Invalid port number\n");
        return 1;
    }

    return start_server(port, db_path, root_dir);
}
