#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <dirent.h>
#include <fcntl.h>
#include <time.h>
#include <netinet/in.h>
#include "ftp_server.h"

int handle_get(client_session_t *session, const void *data, uint16_t length) {
    if (length < 2) {
        send_error_response(session->socket_fd, "Invalid GET format");
        return -1;
    }
    
    uint16_t filename_len = ntohs(*(uint16_t*)data);
    if (filename_len > MAX_FILENAME_LEN || length < 2 + filename_len) {
        send_error_response(session->socket_fd, "Invalid filename length");
        return -1;
    }
    
    char filename[MAX_FILENAME_LEN + 1];
    memcpy(filename, (char*)data + 2, filename_len);
    filename[filename_len] = '\0';
    
    // Open file
    int fd = open(filename, O_RDONLY);
    if (fd < 0) {
        send_error_response(session->socket_fd, "File not found");
        return 0;
    }
    
    // Get file size
    struct stat st;
    if (fstat(fd, &st) < 0) {
        close(fd);
        send_error_response(session->socket_fd, "Cannot stat file");
        return 0;
    }
    
    // Create response
    size_t response_size = 4 + st.st_size;  // file_size + file_data
    char *response = malloc(response_size);
    *(uint32_t*)response = htonl(st.st_size);
    
    // Read file data
    ssize_t bytes_read = read(fd, response + 4, st.st_size);
    close(fd);
    
    if (bytes_read != st.st_size) {
        free(response);
        send_error_response(session->socket_fd, "Error reading file");
        return 0;
    }
    
    send_packet(session->socket_fd, RESP_FILE_DATA, response, response_size);
    free(response);
    
    printf("[PID %d] File '%s' sent (%ld bytes)\n", session->pid, filename, st.st_size);
    return 0;
}

int handle_put(client_session_t *session, const void *data, uint16_t length) {
    if (length < 6) {  // filename_len(2) + file_size(4)
        send_error_response(session->socket_fd, "Invalid PUT format");
        return -1;
    }
    
    uint16_t filename_len = ntohs(*(uint16_t*)data);
    if (filename_len > MAX_FILENAME_LEN || length < 6 + filename_len) {
        send_error_response(session->socket_fd, "Invalid filename length");
        return -1;
    }
    
    char filename[MAX_FILENAME_LEN + 1];
    memcpy(filename, (char*)data + 2, filename_len);
    filename[filename_len] = '\0';
    
    uint32_t declared_size = ntohl(*(uint32_t*)((char*)data + 2 + filename_len));
    
    // VULNERABILITY: Medium - Heap overflow in PUT command
    // Allocate buffer based on declared size, but don't validate actual data length
    char *file_buffer = malloc(declared_size);
    if (!file_buffer) {
        send_error_response(session->socket_fd, "Memory allocation failed");
        return -1;
    }
    
    // Calculate actual data length received
    uint16_t actual_data_len = length - (6 + filename_len);
    
    // BUGGY: Copy actual data without checking if it exceeds declared_size
    // This allows heap overflow if actual_data_len > declared_size
    memcpy(file_buffer, (char*)data + 6 + filename_len, actual_data_len);
    
    // Open file for writing
    int fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (fd < 0) {
        free(file_buffer);
        send_error_response(session->socket_fd, "Cannot create file");
        return 0;
    }
    
    // Write the actual received data (not declared size)
    ssize_t bytes_written = write(fd, file_buffer, actual_data_len);
    close(fd);
    free(file_buffer);
    
    if (bytes_written != actual_data_len) {
        send_error_response(session->socket_fd, "Error writing file");
        return 0;
    }
    
    send_success_response(session->socket_fd, "File uploaded successfully");
    printf("[PID %d] File '%s' uploaded (%d bytes)\n", session->pid, filename, actual_data_len);
    return 0;
}

int handle_list(client_session_t *session, const void *data, uint16_t length) {
    char path[256];  // VULNERABILITY: Easy - Fixed size buffer for path
    
    if (length < 2) {
        strcpy(path, ".");  // Default to current directory
    } else {
        uint16_t path_len = ntohs(*(uint16_t*)data);
        
        // BUGGY: No bounds checking - can overflow path buffer
        if (path_len >= sizeof(path)) {
            // Should validate, but we don't (vulnerability)
        }
        
        memcpy(path, (char*)data + 2, path_len);
        path[path_len] = '\0';
        
        // ADDITIONAL VULNERABILITY: Path concatenation without bounds check
        char temp_path[64];  // Even smaller buffer
        strcpy(temp_path, "./");
        strcat(temp_path, path);  // Can overflow temp_path
        strcpy(path, temp_path);
    }
    
    DIR *dir = opendir(path);
    if (!dir) {
        send_error_response(session->socket_fd, "Cannot open directory");
        return 0;
    }
    
    // Count entries first
    struct dirent *entry;
    uint16_t entry_count = 0;
    while ((entry = readdir(dir)) != NULL) {
        if (strcmp(entry->d_name, ".") != 0 && strcmp(entry->d_name, "..") != 0) {
            entry_count++;
        }
    }
    rewinddir(dir);
    
    // Calculate response size
    size_t response_size = 2;  // entry_count
    size_t entries_size = 0;
    
    // Create response buffer
    char *response = malloc(MAX_PACKET_SIZE);
    *(uint16_t*)response = htons(entry_count);
    size_t offset = 2;
    
    // Add directory entries
    uint16_t actual_count = 0;
    while ((entry = readdir(dir)) != NULL && actual_count < entry_count) {
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0) {
            continue;
        }
        
        struct stat st;
        char full_path[512];
        snprintf(full_path, sizeof(full_path), "%s/%s", path, entry->d_name);
        
        if (stat(full_path, &st) == 0) {
            uint8_t file_type = S_ISDIR(st.st_mode) ? 1 : 0;
            uint16_t name_len = strlen(entry->d_name);
            uint32_t file_size = st.st_size;
            uint32_t mod_time = st.st_mtime;
            
            // Add entry to response
            *(uint8_t*)(response + offset) = file_type;
            offset += 1;
            *(uint16_t*)(response + offset) = htons(name_len);
            offset += 2;
            memcpy(response + offset, entry->d_name, name_len);
            offset += name_len;
            *(uint32_t*)(response + offset) = htonl(file_size);
            offset += 4;
            *(uint32_t*)(response + offset) = htonl(mod_time);
            offset += 4;
            
            actual_count++;
        }
    }
    
    closedir(dir);
    
    send_packet(session->socket_fd, RESP_FILE_LIST, response, offset);
    free(response);
    
    printf("[PID %d] Directory '%s' listed (%d entries)\n", session->pid, path, actual_count);
    return 0;
}

int handle_search(client_session_t *session, const void *data, uint16_t length) {
    if (length < 8) {  // pattern_len(4) + max_results(4)
        send_error_response(session->socket_fd, "Invalid SEARCH format");
        return -1;
    }
    
    uint32_t pattern_len = ntohl(*(uint32_t*)data);
    uint32_t max_results = ntohl(*(uint32_t*)((char*)data + 4));
    
    if (length < 8 + pattern_len) {
        send_error_response(session->socket_fd, "Invalid pattern length");
        return -1;
    }
    
    // VULNERABILITY: Hard - Integer overflow in buffer calculation
    // If pattern_len is very large (close to UINT32_MAX), 
    // pattern_len + 1 will wrap around to a small number
    size_t buffer_size = pattern_len + 1;  // +1 for null terminator
    
    // This allocation might be much smaller than expected due to integer overflow
    char *pattern_buffer = malloc(buffer_size);
    if (!pattern_buffer) {
        send_error_response(session->socket_fd, "Memory allocation failed");
        return -1;
    }
    
    // BUGGY: Copy pattern_len bytes into potentially much smaller buffer
    // If pattern_len wrapped around, this causes massive heap corruption
    memcpy(pattern_buffer, (char*)data + 8, pattern_len);
    pattern_buffer[pattern_len] = '\0';  // This might also be out of bounds
    
    // Search implementation (simplified)
    DIR *dir = opendir(".");
    if (!dir) {
        free(pattern_buffer);
        send_error_response(session->socket_fd, "Cannot open directory");
        return 0;
    }
    
    // Create response buffer
    char *response = malloc(MAX_PACKET_SIZE);
    *(uint16_t*)response = 0;  // result count (will be updated)
    size_t offset = 2;
    uint16_t result_count = 0;
    
    struct dirent *entry;
    while ((entry = readdir(dir)) != NULL && result_count < max_results) {
        if (strstr(entry->d_name, pattern_buffer)) {
            struct stat st;
            if (stat(entry->d_name, &st) == 0) {
                uint16_t path_len = strlen(entry->d_name);
                uint32_t file_size = st.st_size;
                
                // Add to response
                *(uint16_t*)(response + offset) = htons(path_len);
                offset += 2;
                memcpy(response + offset, entry->d_name, path_len);
                offset += path_len;
                *(uint32_t*)(response + offset) = htonl(file_size);
                offset += 4;
                
                result_count++;
            }
        }
    }
    
    closedir(dir);
    free(pattern_buffer);
    
    // Update result count
    *(uint16_t*)response = htons(result_count);
    
    send_packet(session->socket_fd, RESP_SEARCH_RESULTS, response, offset);
    free(response);
    
    printf("[PID %d] Search completed (%d results)\n", session->pid, result_count);
    return 0;
}

int handle_mkdir(client_session_t *session, const void *data, uint16_t length) {
    if (length < 2) {
        send_error_response(session->socket_fd, "Invalid MKDIR format");
        return -1;
    }
    
    uint16_t dirname_len = ntohs(*(uint16_t*)data);
    if (dirname_len > MAX_FILENAME_LEN || length < 2 + dirname_len) {
        send_error_response(session->socket_fd, "Invalid directory name length");
        return -1;
    }
    
    char dirname[MAX_FILENAME_LEN + 1];
    memcpy(dirname, (char*)data + 2, dirname_len);
    dirname[dirname_len] = '\0';
    
    if (mkdir(dirname, 0755) < 0) {
        send_error_response(session->socket_fd, "Cannot create directory");
        return 0;
    }
    
    send_success_response(session->socket_fd, "Directory created successfully");
    printf("[PID %d] Directory '%s' created\n", session->pid, dirname);
    return 0;
}

int handle_delete(client_session_t *session, const void *data, uint16_t length) {
    if (length < 2) {
        send_error_response(session->socket_fd, "Invalid DELETE format");
        return -1;
    }
    
    uint16_t filename_len = ntohs(*(uint16_t*)data);
    if (filename_len > MAX_FILENAME_LEN || length < 2 + filename_len) {
        send_error_response(session->socket_fd, "Invalid filename length");
        return -1;
    }
    
    char filename[MAX_FILENAME_LEN + 1];
    memcpy(filename, (char*)data + 2, filename_len);
    filename[filename_len] = '\0';
    
    if (unlink(filename) < 0) {
        send_error_response(session->socket_fd, "Cannot delete file");
        return 0;
    }
    
    send_success_response(session->socket_fd, "File deleted successfully");
    printf("[PID %d] File '%s' deleted\n", session->pid, filename);
    return 0;
}

int handle_rename(client_session_t *session, const void *data, uint16_t length) {
    if (length < 4) {
        send_error_response(session->socket_fd, "Invalid RENAME format");
        return -1;
    }
    
    uint16_t old_len = ntohs(*(uint16_t*)data);
    if (old_len > MAX_FILENAME_LEN || length < 4 + old_len) {
        send_error_response(session->socket_fd, "Invalid old filename length");
        return -1;
    }
    
    char oldname[MAX_FILENAME_LEN + 1];
    memcpy(oldname, (char*)data + 2, old_len);
    oldname[old_len] = '\0';
    
    uint16_t new_len = ntohs(*(uint16_t*)((char*)data + 2 + old_len));
    if (new_len > MAX_FILENAME_LEN || length < 4 + old_len + new_len) {
        send_error_response(session->socket_fd, "Invalid new filename length");
        return -1;
    }
    
    char newname[MAX_FILENAME_LEN + 1];
    memcpy(newname, (char*)data + 4 + old_len, new_len);
    newname[new_len] = '\0';
    
    if (rename(oldname, newname) < 0) {
        send_error_response(session->socket_fd, "Cannot rename file");
        return 0;
    }
    
    send_success_response(session->socket_fd, "File renamed successfully");
    printf("[PID %d] File '%s' renamed to '%s'\n", session->pid, oldname, newname);
    return 0;
}

int handle_stat(client_session_t *session, const void *data, uint16_t length) {
    if (length < 2) {
        send_error_response(session->socket_fd, "Invalid STAT format");
        return -1;
    }
    
    uint16_t path_len = ntohs(*(uint16_t*)data);
    if (path_len > MAX_PATH_LEN || length < 2 + path_len) {
        send_error_response(session->socket_fd, "Invalid path length");
        return -1;
    }
    
    char path[MAX_PATH_LEN + 1];
    memcpy(path, (char*)data + 2, path_len);
    path[path_len] = '\0';
    
    struct stat st;
    if (stat(path, &st) < 0) {
        send_error_response(session->socket_fd, "Cannot stat file");
        return 0;
    }
    
    // Create response
    char response[11];  // type(1) + size(4) + modified(4) + permissions(2)
    response[0] = S_ISDIR(st.st_mode) ? 1 : 0;
    *(uint32_t*)(response + 1) = htonl(st.st_size);
    *(uint32_t*)(response + 5) = htonl(st.st_mtime);
    *(uint16_t*)(response + 9) = htons(st.st_mode & 0777);
    
    send_packet(session->socket_fd, RESP_STAT_INFO, response, sizeof(response));
    
    printf("[PID %d] Stat info sent for '%s'\n", session->pid, path);
    return 0;
}
