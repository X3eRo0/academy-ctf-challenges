#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>
#include <openssl/sha.h>
#include <sqlite3.h>
#include <time.h>
#include "ftp_server.h"

static sqlite3 *g_db = NULL;

int init_database(const char *db_path) {
    int rc = sqlite3_open(db_path, &g_db);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "Cannot open database: %s\n", sqlite3_errmsg(g_db));
        return -1;
    }
    
    // Create users table
    const char *create_table_sql = 
        "CREATE TABLE IF NOT EXISTS users ("
        "id INTEGER PRIMARY KEY AUTOINCREMENT,"
        "username TEXT UNIQUE NOT NULL,"
        "password_hash TEXT NOT NULL,"
        "salt TEXT NOT NULL,"
        "home_directory TEXT NOT NULL,"
        "created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP"
        ");";
    
    char *err_msg = NULL;
    rc = sqlite3_exec(g_db, create_table_sql, NULL, NULL, &err_msg);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "SQL error: %s\n", err_msg);
        sqlite3_free(err_msg);
        return -1;
    }
    
    printf("Database initialized successfully\n");
    return 0;
}

void generate_salt(char *salt, size_t len) {
    const char charset[] = "0123456789abcdef";
    srand(time(NULL));
    
    for (size_t i = 0; i < len - 1; i++) {
        salt[i] = charset[rand() % (sizeof(charset) - 1)];
    }
    salt[len - 1] = '\0';
}

void hash_password(const char *password, const char *salt, char *hash) {
    char salted_password[MAX_PASSWORD_LEN + 33];  // password + salt + null
    snprintf(salted_password, sizeof(salted_password), "%s%s", password, salt);
    
    unsigned char sha_hash[SHA256_DIGEST_LENGTH];
    SHA256((unsigned char*)salted_password, strlen(salted_password), sha_hash);
    
    // Convert to hex string
    for (int i = 0; i < SHA256_DIGEST_LENGTH; i++) {
        sprintf(hash + (i * 2), "%02x", sha_hash[i]);
    }
    hash[64] = '\0';
}

int create_user(const char *username, const char *password, const char *home_dir) {
    if (!g_db) {
        fprintf(stderr, "Database not initialized\n");
        return -1;
    }
    
    // Generate salt
    char salt[33];
    generate_salt(salt, sizeof(salt));
    
    // Hash password
    char password_hash[65];
    hash_password(password, salt, password_hash);
    
    // Insert user
    const char *insert_sql = 
        "INSERT INTO users (username, password_hash, salt, home_directory) "
        "VALUES (?, ?, ?, ?);";
    
    sqlite3_stmt *stmt;
    int rc = sqlite3_prepare_v2(g_db, insert_sql, -1, &stmt, NULL);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "Failed to prepare statement: %s\n", sqlite3_errmsg(g_db));
        return -1;
    }
    
    sqlite3_bind_text(stmt, 1, username, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 2, password_hash, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 3, salt, -1, SQLITE_STATIC);
    sqlite3_bind_text(stmt, 4, home_dir, -1, SQLITE_STATIC);
    
    rc = sqlite3_step(stmt);
    sqlite3_finalize(stmt);
    
    if (rc != SQLITE_DONE) {
        fprintf(stderr, "Failed to insert user: %s\n", sqlite3_errmsg(g_db));
        return -1;
    }
    
    printf("User '%s' created successfully\n", username);
    return 0;
}

int verify_user(const char *username, const char *password, user_t *user) {
    if (!g_db) {
        fprintf(stderr, "Database not initialized\n");
        return -1;
    }
    
    const char *select_sql = 
        "SELECT id, username, password_hash, salt, home_directory "
        "FROM users WHERE username = ?;";
    
    sqlite3_stmt *stmt;
    int rc = sqlite3_prepare_v2(g_db, select_sql, -1, &stmt, NULL);
    if (rc != SQLITE_OK) {
        fprintf(stderr, "Failed to prepare statement: %s\n", sqlite3_errmsg(g_db));
        return -1;
    }
    
    sqlite3_bind_text(stmt, 1, username, -1, SQLITE_STATIC);
    
    rc = sqlite3_step(stmt);
    if (rc != SQLITE_ROW) {
        sqlite3_finalize(stmt);
        return -1;  // User not found
    }
    
    // Get user data
    user->id = sqlite3_column_int(stmt, 0);
    strcpy(user->username, (char*)sqlite3_column_text(stmt, 1));
    strcpy(user->password_hash, (char*)sqlite3_column_text(stmt, 2));
    strcpy(user->salt, (char*)sqlite3_column_text(stmt, 3));
    strcpy(user->home_directory, (char*)sqlite3_column_text(stmt, 4));
    
    sqlite3_finalize(stmt);
    
    // Verify password
    char computed_hash[65];
    hash_password(password, user->salt, computed_hash);
    
    if (strcmp(computed_hash, user->password_hash) != 0) {
        return -1;  // Password mismatch
    }
    
    return 0;  // Success
}

int setup_chroot(const char *root_path) {
    // Create directory if it doesn't exist
    struct stat st;
    if (stat(root_path, &st) != 0) {
        if (mkdir(root_path, 0755) != 0) {
            perror("mkdir");
            return -1;
        }
    }
    
    // Change to the directory
    if (chdir(root_path) != 0) {
        perror("chdir");
        return -1;
    }
    
    // Chroot to the directory
    printf("root_path: %s\n", root_path);
    if (chroot(root_path) != 0) {
        perror("chroot");
        return -1;
    }
    
    // Change to root of chroot
    if (chdir("/") != 0) {
        perror("chdir to /");
        return -1;
    }
    
    return 0;
}
