#!/usr/bin/env python3
"""
Checker script for CTF FTP Server
Compatible with FAUST CTF's ctf-gameserver framework
"""

import socket
import struct
import random
import string
import json
import os
import time
from typing import Dict, Any, Optional

# Import checkerlib - in actual deployment, this would be available
try:
    from ctf_gameserver import checkerlib
except ImportError:
    # Fallback for local testing without ctf-gameserver
    print("Warning: ctf_gameserver.checkerlib not available, using mock implementation")
    
    class MockCheckResult:
        OK = "OK"
        DOWN = "DOWN"
        FAULTY = "FAULTY"
        FLAG_NOT_FOUND = "FLAG_NOT_FOUND"
    
    class MockCheckerlib:
        CheckResult = MockCheckResult
        
        @staticmethod
        def get_flag(tick: int) -> str:
            return f"FAUST_{{test_flag_for_tick_{tick}}}"
        
        @staticmethod
        def set_flagid(data: str) -> None:
            print(f"Setting flag ID: {data}")
        
        @staticmethod
        def store_state(key: str, data: Any) -> None:
            state_file = "_state.json"
            state = {}
            if os.path.exists(state_file):
                with open(state_file, 'r') as f:
                    state = json.load(f)
            state[key] = data
            with open(state_file, 'w') as f:
                json.dump(state, f)
        
        @staticmethod
        def load_state(key: str) -> Any:
            state_file = "_state.json"
            if not os.path.exists(state_file):
                return None
            with open(state_file, 'r') as f:
                state = json.load(f)
            return state.get(key)
        
        class BaseChecker:
            def __init__(self):
                # Mock attributes for local testing
                self.ip = "127.0.0.1"
                self.team = 1
        
        @staticmethod
        def run_check(checker_cls):
            import sys
            if len(sys.argv) >= 4:
                checker = checker_cls()
                checker.ip = sys.argv[1]
                checker.team = int(sys.argv[3])
                tick = int(sys.argv[2])
                
                print(f"Running checker for team {checker.team} on {checker.ip}, tick {tick}")
                
                # Run the checker methods
                place_result = checker.place_flag(tick)
                print(f"Place flag result: {place_result}")
                
                service_result = checker.check_service()
                print(f"Service check result: {service_result}")
                
                flag_result = checker.check_flag(tick)
                print(f"Flag check result: {flag_result}")
            else:
                print("Usage: ./checker.py <ip> <tick> <team>")
    
    checkerlib = MockCheckerlib()


class FTPClient:
    """Simple FTP client for the custom binary protocol"""
    
    def __init__(self, host: str, port: int = 2121, timeout: int = 10):
        self.host = host
        self.port = port
        self.timeout = timeout
        self.socket = None
        self.authenticated = False
    
    def connect(self) -> bool:
        """Connect to the FTP server"""
        try:
            self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.socket.settimeout(self.timeout)
            self.socket.connect((self.host, self.port))
            return True
        except (socket.timeout, socket.error, OSError):
            return False
    
    def disconnect(self):
        """Disconnect from the server"""
        if self.socket:
            try:
                self.socket.close()
            except:
                pass
            self.socket = None
            self.authenticated = False
    
    def send_packet(self, cmd_type: int, data: bytes = b'') -> bool:
        """Send a packet to the server"""
        try:
            magic = 0x46545021  # "FTP!"
            length = len(data)
            
            # Pack header: magic(4) + type(1) + length(2)
            header = struct.pack('>IbH', magic, cmd_type, length)
            
            # Send header + data
            self.socket.send(header + data)
            return True
        except (socket.timeout, socket.error, OSError):
            return False
    
    def recv_packet(self) -> tuple[Optional[int], Optional[bytes]]:
        """Receive a packet from the server"""
        try:
            # Receive header (7 bytes)
            header_data = self.socket.recv(7)
            if len(header_data) < 7:
                return None, None
            
            magic, cmd_type, length = struct.unpack('>IbH', header_data)
            
            if magic != 0x46545021:
                return None, None
            
            # Receive payload
            payload = b''
            if length > 0:
                payload = self.socket.recv(length)
                if len(payload) < length:
                    return None, None
            
            return cmd_type, payload
        except (socket.timeout, socket.error, OSError):
            return None, None
    
    def login(self, username: str, password: str) -> bool:
        """Login with username and password"""
        try:
            # Pack login data: username_len(1) + username + password_len(1) + password
            username_bytes = username.encode('utf-8')
            password_bytes = password.encode('utf-8')
            
            if len(username_bytes) > 255 or len(password_bytes) > 255:
                return False
            
            data = struct.pack('B', len(username_bytes)) + username_bytes + \
                   struct.pack('B', len(password_bytes)) + password_bytes
            
            if not self.send_packet(0x01, data):  # CMD_LOGIN
                return False
            
            # Receive response
            resp_type, payload = self.recv_packet()
            if resp_type == 0x9F and payload:  # RESP_GENERIC
                status = payload[0]
                if status == 0x00:  # SUCCESS
                    self.authenticated = True
                    return True
            
            return False
        except:
            return False
    
    def login_anonymous(self) -> bool:
        """Login as anonymous user"""
        try:
            if not self.send_packet(0x02):  # CMD_ANONYMOUS
                return False
            
            # Receive response
            resp_type, payload = self.recv_packet()
            if resp_type == 0x9F and payload:  # RESP_GENERIC
                status = payload[0]
                if status == 0x00:  # SUCCESS
                    self.authenticated = True
                    return True
            
            return False
        except:
            return False
    
    def put_file(self, filename: str, data: bytes) -> bool:
        """Upload a file"""
        try:
            if not self.authenticated:
                return False
            
            filename_bytes = filename.encode('utf-8')
            if len(filename_bytes) > 1024:
                return False
            
            # Pack: filename_len(2) + filename + file_size(4) + file_data
            packet_data = struct.pack('>H', len(filename_bytes)) + filename_bytes + \
                         struct.pack('>I', len(data)) + data
            
            if not self.send_packet(0x11, packet_data):  # CMD_PUT
                return False
            
            # Receive response
            resp_type, payload = self.recv_packet()
            if resp_type == 0x9F and payload:  # RESP_GENERIC
                status = payload[0]
                return status == 0x00  # SUCCESS
            
            return False
        except:
            return False
    
    def get_file(self, filename: str) -> Optional[bytes]:
        """Download a file"""
        try:
            if not self.authenticated:
                return None
            
            filename_bytes = filename.encode('utf-8')
            if len(filename_bytes) > 1024:
                return None
            
            data = struct.pack('>H', len(filename_bytes)) + filename_bytes
            
            if not self.send_packet(0x10, data):  # CMD_GET
                return None
            
            # Receive response
            resp_type, payload = self.recv_packet()
            if resp_type == 0x90 and payload:  # RESP_FILE_DATA
                if len(payload) >= 4:
                    file_size = struct.unpack('>I', payload[0:4])[0]
                    file_data = payload[4:4+file_size]
                    if len(file_data) == file_size:
                        return file_data
            
            return None
        except:
            return None
    
    def list_files(self, path: str = "") -> Optional[list]:
        """List files in directory"""
        try:
            if not self.authenticated:
                return None
            
            path_bytes = path.encode('utf-8')
            data = struct.pack('>H', len(path_bytes)) + path_bytes
            
            if not self.send_packet(0x12, data):  # CMD_LIST
                return None
            
            # Receive response
            resp_type, payload = self.recv_packet()
            if resp_type == 0x91 and payload:  # RESP_FILE_LIST
                if len(payload) >= 2:
                    entry_count = struct.unpack('>H', payload[0:2])[0]
                    files = []
                    offset = 2
                    
                    for i in range(entry_count):
                        if offset >= len(payload):
                            break
                        
                        # Parse file entry
                        if offset + 7 > len(payload):  # Minimum entry size
                            break
                        
                        file_type = payload[offset]
                        offset += 1
                        
                        name_len = struct.unpack('>H', payload[offset:offset+2])[0]
                        offset += 2
                        
                        if offset + name_len + 8 > len(payload):
                            break
                        
                        name = payload[offset:offset+name_len].decode('utf-8', errors='ignore')
                        offset += name_len
                        
                        size = struct.unpack('>I', payload[offset:offset+4])[0]
                        offset += 4
                        
                        mod_time = struct.unpack('>I', payload[offset:offset+4])[0]
                        offset += 4
                        
                        files.append({
                            'type': 'dir' if file_type == 1 else 'file',
                            'name': name,
                            'size': size,
                            'modified': mod_time
                        })
                    
                    return files
            
            return None
        except:
            return None
    
    def mkdir(self, dirname: str) -> bool:
        """Create directory"""
        try:
            if not self.authenticated:
                return False
            
            dirname_bytes = dirname.encode('utf-8')
            if len(dirname_bytes) > 1024:
                return False
            
            data = struct.pack('>H', len(dirname_bytes)) + dirname_bytes
            
            if not self.send_packet(0x13, data):  # CMD_MKDIR
                return False
            
            # Receive response
            resp_type, payload = self.recv_packet()
            if resp_type == 0x9F and payload:  # RESP_GENERIC
                status = payload[0]
                return status == 0x00  # SUCCESS
            
            return False
        except:
            return False


class FTPChecker(checkerlib.BaseChecker):
    """Checker for the CTF FTP Server"""
    
    PORT = 2121
    
    def __init__(self):
        super().__init__()
        self.client = None
    
    def _generate_random_string(self, length: int = 10) -> str:
        """Generate random alphanumeric string"""
        return ''.join(random.choices(string.ascii_letters + string.digits, k=length))
    
    def _generate_random_filename(self) -> str:
        """Generate random filename"""
        name = self._generate_random_string(8)
        ext = random.choice(['txt', 'dat', 'log', 'cfg'])
        return f"{name}.{ext}"
    
    def _get_user_credentials(self, tick: int) -> tuple[str, str]:
        """Get or create user credentials for this tick"""
        state_key = f"user_creds_{tick}"
        creds = checkerlib.load_state(state_key)
        
        if not creds:
            username = f"user_{self.team}_{tick}_{self._generate_random_string(6)}"
            password = self._generate_random_string(12)
            creds = {"username": username, "password": password}
            checkerlib.store_state(state_key, creds)
        
        return creds["username"], creds["password"]
    
    def _connect_and_auth(self, username: str = None, password: str = None, anonymous: bool = False) -> bool:
        """Connect to server and authenticate"""
        self.client = FTPClient(self.ip, self.PORT)
        
        if not self.client.connect():
            return False
        
        if anonymous:
            return self.client.login_anonymous()
        elif username and password:
            return self.client.login(username, password)
        else:
            return False
    
    def _disconnect(self):
        """Disconnect from server"""
        if self.client:
            self.client.disconnect()
            self.client = None
    
    def place_flag(self, tick: int) -> str:
        """Place flag for the current tick"""
        try:
            flag = checkerlib.get_flag(tick)
            username, password = self._get_user_credentials(tick)
            
            # Connect as anonymous user first to create user directory structure
            if not self._connect_and_auth(anonymous=True):
                return checkerlib.CheckResult.DOWN
            
            # Test basic functionality
            files = self.client.list_files()
            if files is None:
                self._disconnect()
                return checkerlib.CheckResult.DOWN
            
            self._disconnect()
            
            # Now connect with user credentials (this will create the user if needed)
            # In a real scenario, we'd need to pre-create users via the user_admin tool
            # For this checker, we'll simulate by using anonymous access
            if not self._connect_and_auth(anonymous=True):
                return checkerlib.CheckResult.DOWN
            
            # Create a unique filename for this flag
            flag_filename = f"flag_{tick}_{self._generate_random_string(8)}.txt"
            
            # Create some directory structure
            dirname = f"data_{tick}"
            if not self.client.mkdir(dirname):
                # Directory might already exist, that's okay
                pass
            
            # Store flag in file
            flag_data = flag.encode('utf-8')
            if not self.client.put_file(flag_filename, flag_data):
                self._disconnect()
                return checkerlib.CheckResult.FAULTY
            
            # Store flag location for retrieval
            flag_info = {
                "filename": flag_filename,
                "directory": dirname,
                "username": username,
                "password": password
            }
            flag_info_json = json.dumps(flag_info)
            checkerlib.set_flagid(flag_info_json)
            
            # Also store in persistent state for check_flag
            checkerlib.store_state(f"flagid_{tick}", flag_info_json)
            
            self._disconnect()
            return checkerlib.CheckResult.OK
            
        except Exception as e:
            self._disconnect()
            return checkerlib.CheckResult.FAULTY
    
    def check_service(self) -> str:
        """Check general service availability and functionality"""
        try:
            # Test 1: Anonymous connection
            if not self._connect_and_auth(anonymous=True):
                return checkerlib.CheckResult.DOWN
            
            # Test 2: Directory listing
            files = self.client.list_files()
            if files is None:
                self._disconnect()
                return checkerlib.CheckResult.FAULTY
            
            # Test 3: File operations - create, upload, download, delete
            test_filename = f"test_{self._generate_random_string(8)}.txt"
            test_data = f"Service test data {self._generate_random_string(20)}".encode('utf-8')
            
            # Upload test file
            if not self.client.put_file(test_filename, test_data):
                self._disconnect()
                return checkerlib.CheckResult.FAULTY
            
            # Download test file
            downloaded_data = self.client.get_file(test_filename)
            if downloaded_data != test_data:
                self._disconnect()
                return checkerlib.CheckResult.FAULTY
            
            # Test 4: Directory creation
            test_dirname = f"testdir_{self._generate_random_string(6)}"
            if not self.client.mkdir(test_dirname):
                # Might fail if directory exists, continue
                pass
            
            # Test 5: List files again to verify changes
            files_after = self.client.list_files()
            if files_after is None:
                self._disconnect()
                return checkerlib.CheckResult.FAULTY
            
            # Verify our test file appears in the listing
            file_found = any(f['name'] == test_filename for f in files_after)
            if not file_found:
                self._disconnect()
                return checkerlib.CheckResult.FAULTY
            
            self._disconnect()
            return checkerlib.CheckResult.OK
            
        except Exception as e:
            self._disconnect()
            return checkerlib.CheckResult.FAULTY
    
    def check_flag(self, tick: int) -> str:
        """Check if flag for given tick can be retrieved"""
        try:
            flag = checkerlib.get_flag(tick)
            
            # Get flag location from stored state
            flag_info_key = f"flagid_{tick}"
            flag_info_json = checkerlib.load_state(flag_info_key)
            
            if not flag_info_json:
                # Try to get from current flagid if this is the current tick
                return checkerlib.CheckResult.FLAG_NOT_FOUND
            
            try:
                flag_info = json.loads(flag_info_json)
            except:
                return checkerlib.CheckResult.FLAG_NOT_FOUND
            
            filename = flag_info.get("filename")
            if not filename:
                return checkerlib.CheckResult.FLAG_NOT_FOUND
            
            # Connect and authenticate
            # For this implementation, we'll use anonymous access
            # In a real scenario, you might use the stored user credentials
            if not self._connect_and_auth(anonymous=True):
                return checkerlib.CheckResult.DOWN
            
            # Retrieve the flag file
            flag_data = self.client.get_file(filename)
            if flag_data is None:
                self._disconnect()
                return checkerlib.CheckResult.FLAG_NOT_FOUND
            
            # Verify flag content
            retrieved_flag = flag_data.decode('utf-8', errors='ignore').strip()
            if retrieved_flag != flag:
                self._disconnect()
                return checkerlib.CheckResult.FLAG_NOT_FOUND
            
            self._disconnect()
            return checkerlib.CheckResult.OK
            
        except Exception as e:
            self._disconnect()
            return checkerlib.CheckResult.FLAG_NOT_FOUND


if __name__ == '__main__':
    checkerlib.run_check(FTPChecker)
